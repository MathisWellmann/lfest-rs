--- src/order_rate_limiter.rs
+++ replace < with > in OrderRateLimiter::is_in_bucket
@@ -26,17 +26,17 @@
     /// If `true`, the `current_ts_ns` falls within the current bucket.
     #[inline(always)]
     fn is_in_bucket(&self, current_ts_ns: TimestampNs) -> bool {
         debug_assert!(
             current_ts_ns >= self.bucket_start_ns,
             "Timestamps are assumed to always increment. Here we don't additionally check for the lower bound of the bucket."
         );
         let bucket_end_ts_ns = self.bucket_start_ns + NANOS_PER_SECOND.into();
-        current_ts_ns < bucket_end_ts_ns
+        current_ts_ns > /* ~ changed by cargo-mutants ~ */ bucket_end_ts_ns
     }
 
     /// Set the new bucket start timestamp by rounding to the nearest second.
     #[inline(always)]
     fn new_bucket(&mut self, current_ts_ns: TimestampNs) {
         let ns = *current_ts_ns.as_ref();
         self.bucket_start_ns = (ns - ns % NANOS_PER_SECOND).into();
         self.remaining = self.orders_per_second;
